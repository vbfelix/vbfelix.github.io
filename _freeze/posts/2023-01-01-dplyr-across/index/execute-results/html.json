{
  "hash": "c4a6d29fad65c392a913e6f6447231fd",
  "result": {
    "markdown": "---\ntitle: \"An intro to dplyr::across\"\nauthor: \"Vinícius Félix\"\ndate: \"2023-01-01\"\ncategories: [R,Intro to,Tidyverse]\nimage: \"intro-to-dplyr-across.png\"\n---\n\n\nIn this post of the series **Intro to**, I'll give an introduction to the function `across` of the R package `dplyr`.\n\n# History\n\nAs described in their site, [Tidyverse](https://www.tidyverse.org/) is an opinionated collection of R packages developed for data applications. One of the ecosystem main packages is [dplyr](https://dplyr.tidyverse.org/), which offers a consistent set of verbs to assist you in resolving data manipulation problems.\n\nIn June of 2020 we had the official release of [dplyr 1.0.0](https://www.tidyverse.org/blog/2020/06/dplyr-1-0-0/) where a new function was introduced to us, opening new possibilities to data manipulation, that was the birth of `across` one of the most powerful and versatily functions to work with data, before talking about it let's see how we used to work before.\n\n## Before across\n\nAs one of thre greatest R packages `dplyr` possesses a lot functions, but it has two main verbs to manipulate data, they are:\n\n-   `summarise`: allows us to apply a transformation that reduce the number of observations, e.g., mean;\n\n-   `mutate`: allows us to apply transformation to our existing variables or even creating new ones with the same size, e.g., multiplying one variable by another.\n\nLet's see how they work in practice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\nglimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel~\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <fct> male, female, female, NA, female, male, female, male~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nGiven the dataset `penguins` from the package `palmerpenguins` we will summarise each numeric variable, computing the mean for each one. Then, we can apply the `mean` function to each variable, inside the verb `summarise`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    mean(bill_length_mm,na.rm = TRUE),\n    mean(bill_depth_mm,na.rm = TRUE),\n    mean(flipper_length_mm,na.rm = TRUE),\n    mean(body_mass_g,na.rm = TRUE)\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ `mean(bill_length_mm, na.rm = TRUE)`    <dbl> 43.92193\n$ `mean(bill_depth_mm, na.rm = TRUE)`     <dbl> 17.15117\n$ `mean(flipper_length_mm, na.rm = TRUE)` <dbl> 200.9152\n$ `mean(body_mass_g, na.rm = TRUE)`       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we see that it works, but have some problems:\n\n1.  It is very manual, so if we had many columns it would became a tedious activity, besides the higher probability of human error by writing a lot of lines or even copy and pasting the code;\n\n2.  WIthout setting the names of the new tvariables, they will receive the function as their new names.\n\nA smarter approach is the use of a `summarise` variant, called `summarise_if`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise_if(\n    .predicate = is.numeric,\n    .funs = ~mean(.,na.rm = TRUE)\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 5\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n$ year              <dbl> 2008.029\n```\n:::\n:::\n\n\nIn the example above we see that inside `summarise_if` we define two argumens:\n\n1.  `.predicate`: the condition to check which variables we are going to apply the functions;\n\n2.  `.funs`: a function or list of functions.\n\nDifferent from the first approach here the function kept the name of the original variables, even though they are the mean's of the originals. Another benefit is the reduction of lines of code, since now with 2 lines we applied a function to 5 columns.\n\nSo it worked, but what's the problem? Let's say that I also want to know the mode of the variable `species`, how I could do that?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    species = relper::calc_mode(species),\n    across(.cols = where(is.numeric),.fns = ~mean(.,na.rm = TRUE))\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 6\n$ species           <fct> Adelie\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n$ year              <dbl> 2008.029\n```\n:::\n:::\n\n\nIn the example above we apply `across` , we see that it is used inside the conventional verb `summarise` , meaning we can still apply other functions even using `across`.\n\nSo `across` is a function that is complementary to `mutate` and `summarise`, that allows us to apply multiples functions across multiples variables.\n\nJust as curiosity, even though this old functions are superseeded they still exists, and their suffixes are `_at()` , `_if()` and `_all()` .\n\n# across\n\nNow that we understood the overall goal of `across`, we will explore each argument.\n\n## .cols\n\nThe first argument of `across` determine which columns of the data.frame we are going to apply our functions, this argument is:\n\n-   Non-optional\n\n-   The default is every single variable of the data.frame, by using the function `everything`.\n\n-   Accepts as input:\n\n    -   Numbers, referencing the variables positions;\n\n    -   Strings, referencing the variables names;\n\n    -   Select helpers functions, e.g., `contains`, as we will see below.\n\n### Default\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.fns = as.character)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A~\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", ~\n$ bill_length_mm    <chr> \"39.1\", \"39.5\", \"40.3\", NA, \"36.7\", \"39.3\", \"38.9\", ~\n$ bill_depth_mm     <chr> \"18.7\", \"17.4\", \"18\", NA, \"19.3\", \"20.6\", \"17.8\", \"1~\n$ flipper_length_mm <chr> \"181\", \"186\", \"195\", NA, \"193\", \"190\", \"181\", \"195\",~\n$ body_mass_g       <chr> \"3750\", \"3800\", \"3250\", NA, \"3450\", \"3650\", \"3625\", ~\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f~\n$ year              <chr> \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"200~\n```\n:::\n:::\n\n\nIn the example above we apply the function `as.character` to every column, since we did not use an input to the argument `.cols`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = everything(),.fns = as.character)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A~\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", ~\n$ bill_length_mm    <chr> \"39.1\", \"39.5\", \"40.3\", NA, \"36.7\", \"39.3\", \"38.9\", ~\n$ bill_depth_mm     <chr> \"18.7\", \"17.4\", \"18\", NA, \"19.3\", \"20.6\", \"17.8\", \"1~\n$ flipper_length_mm <chr> \"181\", \"186\", \"195\", NA, \"193\", \"190\", \"181\", \"195\",~\n$ body_mass_g       <chr> \"3750\", \"3800\", \"3250\", NA, \"3450\", \"3650\", \"3625\", ~\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f~\n$ year              <chr> \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"200~\n```\n:::\n:::\n\n\nIn the example above we see that same result is obtained, since the default of `.cols` is `everything`.\n\n### By type\n\nIf we want to select variables by their type we can use the verb `where` + a function that check the variable type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  mutate(across(.cols = where(is.factor),.fns = toupper)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"A~\n$ island            <chr> \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", ~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <chr> \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\", \"F~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nIn the example above we made all factor variables to be uppercase.\n\nOther function can also be used, such as:\n\n-   `is.numeric:` check if the variable is numeric;\n\n    -   `is.integer` check if the variable is an integer;\n\n    -   `is.double` check if the variable is a double;\n\n-   `is.factor` check if the variable is a factor;\n\n-   `is.character` check if the variable is a character;\n\n-   `is.logical` check if the variable is a boolean (`TRUE`/`FALSE`).\n\nWe can also combine more than one variable in the same `across`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  mutate(across(.cols = where(is.factor) | where(is.character),.fns = toupper)) %>%   glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"A~\n$ island            <chr> \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", ~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <chr> \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\", \"F~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nIn the example above we made all factor (`species` and `island`) and character (`sex`) variables to be uppercase.\n\n### By name\n\nAnother method of column selection is by using their name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = ends_with(\"_mm\"),.fns = ~mean(.,na.rm = TRUE))) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 3\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n```\n:::\n:::\n\n\nIn the example above we compute the mean for the variables that ends with the pattern *`_mm`.*\n\nSo all the the selection helpers can be used:\n\n-   `all_of`: allows us to pass a string vector to select specific variables, that does not check other conditions, e.g., `all_of(-vector_of_variables)` ;\n\n-   `any_of:` has a similar function to `all_of` , but it can be used to remove variables with the operator `-`, e.g., `any_of(-vector_of_variables)` ;\n\n-   `contains`: variables that contains a specific string in their names;\n\n-   `ends_with`: variables that ends with a specific string pattern;\n\n-   `everything`: all variables, and already the default of the argument `.cols`;\n\n-   `last_col`: the last variable;\n\n-   `matches`: variables with a name that matches a given regular expression;\n\n-   `num_range`: variables that have a numeric sequence in their name, e.g., `var1`, `var2` and `var3` then we can use `num_range(\"var\",1:3)`;\n\n-   `starts_with`: variables that starts with a specific string pattern.\n\n### By order\n\nAnother method of columns selection is using the name of the variables and the operator `:` to apply the function to a sequence of variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = bill_length_mm:body_mass_g,.fns = ~mean(.,na.rm = TRUE))) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we compute the mean to every variable from `bill_length_mm` to `body_mass_g`.\n\nWe can see that this variables are third to sixth of the data.frame, then can also use a method to reference them by their position.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = 3:6,.fns = ~mean(.,na.rm = TRUE))) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we computed the mean for the same variables as before, but now using their column position instead.\n\n## .fns\n\nThe argument `.fns` determine which functions are going to be applied, this argument is:\n\n-   Non-optional\n\n-   No default\n\n-   Accepts as input:\n\n    -   Single function;\n\n    -   List of functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        ~mean(.,na.rm = TRUE),\n        ~median(.,na.rm = TRUE)\n      )\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ bill_length_mm_1    <dbl> 43.92193\n$ bill_length_mm_2    <dbl> 44.45\n$ bill_depth_mm_1     <dbl> 17.15117\n$ bill_depth_mm_2     <dbl> 17.3\n$ flipper_length_mm_1 <dbl> 200.9152\n$ flipper_length_mm_2 <dbl> 197\n$ body_mass_g_1       <dbl> 4201.754\n$ body_mass_g_2       <dbl> 4050\n$ year_1              <dbl> 2008.029\n$ year_2              <dbl> 2008\n```\n:::\n:::\n\n\nIn the example above we can see that both the mean and median are computed, but as more than one function is applied to the same variable a numeric suffix is added, by the order we defined our functions inside the list, this can be confusing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        mean = ~mean(.,na.rm = TRUE),\n        median = ~median(.,na.rm = TRUE)\n      )\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ bill_length_mm_mean      <dbl> 43.92193\n$ bill_length_mm_median    <dbl> 44.45\n$ bill_depth_mm_mean       <dbl> 17.15117\n$ bill_depth_mm_median     <dbl> 17.3\n$ flipper_length_mm_mean   <dbl> 200.9152\n$ flipper_length_mm_median <dbl> 197\n$ body_mass_g_mean         <dbl> 4201.754\n$ body_mass_g_median       <dbl> 4050\n$ year_mean                <dbl> 2008.029\n$ year_median              <dbl> 2008\n```\n:::\n:::\n\n\nIn the example above we defined the name of functions inside the list, now they are added as suffixes, which make easier to see what are we doing.\n\n## .names\n\nThe argument `.names` determines the result of the variables names after the functions are applied, so it allows us to change the names of the variables, this argument is:\n\n-   Optional\n\n-   The default is `NULL`\n\n-   Accepts as input:\n\n    -   A string, where we can use `{.col}` and `{.fn}` as variables to receive the respective names of the columns and/or functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        mean = ~mean(.,na.rm = TRUE),\n        median = ~median(.,na.rm = TRUE)\n      ),\n      .names = \"{.fn}----{.col}\"\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ `mean----bill_length_mm`      <dbl> 43.92193\n$ `median----bill_length_mm`    <dbl> 44.45\n$ `mean----bill_depth_mm`       <dbl> 17.15117\n$ `median----bill_depth_mm`     <dbl> 17.3\n$ `mean----flipper_length_mm`   <dbl> 200.9152\n$ `median----flipper_length_mm` <dbl> 197\n$ `mean----body_mass_g`         <dbl> 4201.754\n$ `median----body_mass_g`       <dbl> 4050\n$ `mean----year`                <dbl> 2008.029\n$ `median----year`              <dbl> 2008\n```\n:::\n:::\n\n\nIn the example above we change the variables names so they start with the function applied followed by 4 hyphens and then the original columns names.\n\n# c_across\n\nThe function `c_across` is a cousin of `across` , let´s construct another data.frame to showcase it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nxpenguins <-\n  penguins %>% \n  group_by(species) %>% \n  summarise(\n    heaviest = max(body_mass_g,na.rm = TRUE),\n    lightest = min(body_mass_g,na.rm = TRUE)\n    ) %>%\n  pivot_longer(cols = -species) %>% \n  pivot_wider(names_from = species,values_from = value)\n\nxpenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 4\n  name     Adelie Chinstrap Gentoo\n  <chr>     <int>     <int>  <int>\n1 heaviest   4775      4800   6300\n2 lightest   2850      2700   3950\n```\n:::\n:::\n\n\nIn the example above we build a data.frame in the wide format where we have a column for each species, and two rows, representing the heaviest and lighest penguins of each. Let's say our goal is to compute the total weight of the heaviest and lighest penguins, i.e, summing the weight of the three species in a fourth column called `total_weight`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins %>% \n  mutate(total_weight = Adelie + Chinstrap + Gentoo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 5\n  name     Adelie Chinstrap Gentoo total_weight\n  <chr>     <int>     <int>  <int>        <int>\n1 heaviest   4775      4800   6300        15875\n2 lightest   2850      2700   3950         9500\n```\n:::\n:::\n\n\nIn the example above we can use a simple solution, put every single variable name manually and add each other, that works but is not ideal, specially when we have many columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins %>% \n  rowwise() %>% \n  mutate(total_weight = sum(c_across(-name)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 5\n# Rowwise: \n  name     Adelie Chinstrap Gentoo total_weight\n  <chr>     <int>     <int>  <int>        <int>\n1 heaviest   4775      4800   6300        15875\n2 lightest   2850      2700   3950         9500\n```\n:::\n:::\n\n\nIn the example above we apply `c_across`, first it works together with the verb `rowwise` that make the commands below it to operate by row, not column.\n\nNot only that, but `c_across` is slightly different from `across` it has only a `.cols` argument, so it needs to be put inside a function, with the benefit compared to the first approach that we can use the functions arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins_na <- xpenguins\nxpenguins_na[1,3] <- NA\n  \nxpenguins_na %>% \n  rowwise() %>% \n  mutate(\n    total_weight_plus = Adelie + Chinstrap + Gentoo,\n    total_weight_cacross = sum(c_across(-name),na.rm = TRUE)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 6\n# Rowwise: \n  name     Adelie Chinstrap Gentoo total_weight_plus total_weight_cacross\n  <chr>     <int>     <int>  <int>             <int>                <int>\n1 heaviest   4775        NA   6300                NA                11075\n2 lightest   2850      2700   3950              9500                19000\n```\n:::\n:::\n\n\nIn the example above we show what would happen if we had an `NA` in the data. Most functions in R by default give `NA` as results if a `NA` is present in the data, so we can benefit from the use of the function `sum`, since it has an argument to ignore them (`na.rm = TRUE`).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}