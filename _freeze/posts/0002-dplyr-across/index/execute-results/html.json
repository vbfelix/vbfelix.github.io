{
  "hash": "807acc1fa096449d102cbac782f701d5",
  "result": {
    "markdown": "---\ntitle: \"An intro to: dplyr::across\"\nauthor: \"Vinícius Félix\"\ndate: \"2023-01-02\"\ncategories: [Intro to, R, Tools]\nimage: \"intro-to-dplyr-across.png\"\n---\n\n\nIn this post you will learn to never repeat a function again inside a `dplyr` pipeline.\n\n# Context\n\nAs described in their site, [Tidyverse](https://www.tidyverse.org/) is an opinionated collection of R packages developed for data applications. One of the ecosystem main packages is [dplyr](https://dplyr.tidyverse.org/), which offers a consistent set of verbs to assist you in resolving data manipulation problems.\n\nIn June of 2020 we had the official release of [dplyr 1.0.0](https://www.tidyverse.org/blog/2020/06/dplyr-1-0-0/) where a new function was introduced to us, opening new possibilities to data manipulation, that was the birth of `across` one of the most powerful and versatily functions to work with data.\n\nBefore talking about it, let's see how we used to work before.\n\n## Before across\n\nAs one of thre greatest R packages, `dplyr` possesses a lot functions, but it has two main verbs to manipulate data, they are:\n\n-   `summarise`: allows us to apply a transformation to data that reduce the number of observations, e.g., mean;\n\n-   `mutate`: allows us to apply a transformation to our existing variables or even creating new ones with the same size, e.g., multiplying one variable by 2.\n\nLet's see how they work in practice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\nglimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel~\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <fct> male, female, female, NA, female, male, female, male~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nWe will summarize every numerical variable using the dataset `penguins` from the `palmerpenguins` package, computing the mean for each. The mean function can then be applied to each variable inside the verb `summarize`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    mean(bill_length_mm,na.rm = TRUE),\n    mean(bill_depth_mm,na.rm = TRUE),\n    mean(flipper_length_mm,na.rm = TRUE),\n    mean(body_mass_g,na.rm = TRUE)\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ `mean(bill_length_mm, na.rm = TRUE)`    <dbl> 43.92193\n$ `mean(bill_depth_mm, na.rm = TRUE)`     <dbl> 17.15117\n$ `mean(flipper_length_mm, na.rm = TRUE)` <dbl> 200.9152\n$ `mean(body_mass_g, na.rm = TRUE)`       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we see that it works, but have some problems:\n\n1.  Due to its manual nature and increased risk of human error from writing numerous lines of code or even copying and pasting it, it would become a tiresome task if there were many columns;\n\n2.  The function will be given to the new tvariables as their names if their names are not set.\n\nA smarter approach is the use of a `summarise` variant, called `summarise_if`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise_if(\n    .predicate = is.numeric,\n    .funs = ~mean(.,na.rm = TRUE)\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 5\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n$ year              <dbl> 2008.029\n```\n:::\n:::\n\n\nIn the example above we see that inside `summarise_if` we define two argumens:\n\n1.  `.predicate`: the condition to check which variables we are going to apply the functions;\n\n2.  `.funs`: a function or list of functions.\n\nEven though these variables are the means of the originals, unlike the first method, the function here kept the names of the original variables. The fact that we can now apply a function to 5 columns with only 2 lines of code is another advantage.\n\nSo it was successful, but what is the issue? What if I also wanted to learn the mode of the variable species? How could we go about doing that?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    species = relper::calc_mode(species),\n    across(.cols = where(is.numeric),.fns = ~mean(.,na.rm = TRUE))\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 6\n$ species           <fct> Adelie\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n$ year              <dbl> 2008.029\n```\n:::\n:::\n\n\nIn the example above we apply `across` , we see that it is used inside the conventional verb `summarise` , meaning we can still apply other functions even using `across`.\n\nSo `across` is a function that is complementary to `mutate` and `summarise`, that allows us to apply multiples functions across multiples variables.\n\nJust as curiosity, even though this old functions are superseeded they still exists, and their suffixes are `_at()` , `_if()` and `_all()` .\n\n# across\n\nNow that we understood the overall goal of `across`, we will explore each argument of the function.\n\n## .cols\n\nThe first argument of `across` determine which columns of the data.frame we are going to apply our functions, this argument is:\n\n-   Non-optional\n\n-   The default is every single variable of the data.frame, by using the function `everything`.\n\n-   Accepts as input:\n\n    -   Integers, referencing the variables positions;\n\n    -   Strings, referencing the variables names;\n\n    -   Select helpers functions, e.g., `contains`, as we will see below.\n\n### Default\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.fns = as.character)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A~\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", ~\n$ bill_length_mm    <chr> \"39.1\", \"39.5\", \"40.3\", NA, \"36.7\", \"39.3\", \"38.9\", ~\n$ bill_depth_mm     <chr> \"18.7\", \"17.4\", \"18\", NA, \"19.3\", \"20.6\", \"17.8\", \"1~\n$ flipper_length_mm <chr> \"181\", \"186\", \"195\", NA, \"193\", \"190\", \"181\", \"195\",~\n$ body_mass_g       <chr> \"3750\", \"3800\", \"3250\", NA, \"3450\", \"3650\", \"3625\", ~\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f~\n$ year              <chr> \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"200~\n```\n:::\n:::\n\n\nIn the example above we apply the function `as.character` to every column, since we did not use an input to the argument `.cols`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = everything(),.fns = as.character)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A~\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", ~\n$ bill_length_mm    <chr> \"39.1\", \"39.5\", \"40.3\", NA, \"36.7\", \"39.3\", \"38.9\", ~\n$ bill_depth_mm     <chr> \"18.7\", \"17.4\", \"18\", NA, \"19.3\", \"20.6\", \"17.8\", \"1~\n$ flipper_length_mm <chr> \"181\", \"186\", \"195\", NA, \"193\", \"190\", \"181\", \"195\",~\n$ body_mass_g       <chr> \"3750\", \"3800\", \"3250\", NA, \"3450\", \"3650\", \"3625\", ~\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f~\n$ year              <chr> \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"2007\", \"200~\n```\n:::\n:::\n\n\nIn the example above we see that same result is obtained from the previous, since the default of `.cols` is `everything`.\n\n### By type\n\nIf we want to select variables by their type we can use the function `where` + a function that check the variable type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  mutate(across(.cols = where(is.factor),.fns = toupper)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"A~\n$ island            <chr> \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", ~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <chr> \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\", \"F~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nIn the example above we made all factor variables to be uppercase.\n\nOther functions can also be used, such as:\n\n-   `is.numeric:` check if the variable is numeric;\n\n    -   `is.integer` check if the variable is an integer;\n\n    -   `is.double` check if the variable is a double;\n\n-   `is.factor` check if the variable is a factor;\n\n-   `is.character` check if the variable is a character;\n\n-   `is.logical` check if the variable is a boolean (`TRUE`/`FALSE`).\n\nWe can also combine more than one function in the same `across`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  mutate(across(.cols = where(is.factor) | where(is.character),.fns = toupper)) %>%   glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <chr> \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"ADELIE\", \"A~\n$ island            <chr> \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", \"TORGERSEN\", ~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <chr> \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\", \"F~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nIn the example above we made all factor (`species` and `island`) and character (`sex`) variables to be uppercase.\n\n### By name\n\nAnother method of column selection is by using their name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = ends_with(\"_mm\"),.fns = ~mean(.,na.rm = TRUE))) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 3\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n```\n:::\n:::\n\n\nIn the example above we compute the mean for the variables that ends with the pattern *`_mm`.*\n\nSo all the the selection helpers can be used:\n\n-   `all_of`: allows us to pass a string vector to select specific variables, that helps when we are looking for a group of variables, which not obey a simples check condition such as been of the same type or having the a name pattern, e.g., `all_of(vector_of_variables)` ;\n\n-   `any_of:` is a similar function to `all_of` , but it can be used to remove variables with the operator `-`, e.g., `any_of(-vector_of_variables)` ;\n\n-   `contains`: allows to select variables that contains a specific string in their names. e.g., `contains(length)`;\n\n-   `ends_with`: variables that ends with a specific string pattern, e.g., `ends_with(\"_mm\")`;\n\n-   `everything`: all variables, and already the default of the argument `.cols`;\n\n-   `last_col`: the last variable of the data.frame;\n\n-   `matches`: variables with a name that matches a given regular expression;\n\n-   `num_range`: variables that have a numeric sequence in their name, e.g., `var1`, `var2` and `var3` then we can use `num_range(\"var\",1:3)`;\n\n-   `starts_with`: variables that starts with a specific string pattern, e.g., `starts_with(\"bill_\")`.\n\n### By order\n\nAnother method of column selection is using the name of the variables and the operator `:` to apply the function to a sequence of variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = bill_length_mm:body_mass_g,.fns = ~mean(.,na.rm = TRUE))) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we compute the mean to every variable from `bill_length_mm` to `body_mass_g`.\n\nWe can see that this variables are third to sixth of the data.frame, then can also use a method to reference them by their position.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(across(.cols = 3:6,.fns = ~mean(.,na.rm = TRUE))) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 4\n$ bill_length_mm    <dbl> 43.92193\n$ bill_depth_mm     <dbl> 17.15117\n$ flipper_length_mm <dbl> 200.9152\n$ body_mass_g       <dbl> 4201.754\n```\n:::\n:::\n\n\nIn the example above we computed the mean for the same variables as before, but now using their column position instead.\n\n## .fns\n\nThe argument `.fns` determine which functions are going to be applied, this argument is:\n\n-   Non-optional\n\n-   No default\n\n-   Accepts as input:\n\n    -   Single function;\n\n    -   List of functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        ~mean(.,na.rm = TRUE),\n        ~median(.,na.rm = TRUE)\n      )\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ bill_length_mm_1    <dbl> 43.92193\n$ bill_length_mm_2    <dbl> 44.45\n$ bill_depth_mm_1     <dbl> 17.15117\n$ bill_depth_mm_2     <dbl> 17.3\n$ flipper_length_mm_1 <dbl> 200.9152\n$ flipper_length_mm_2 <dbl> 197\n$ body_mass_g_1       <dbl> 4201.754\n$ body_mass_g_2       <dbl> 4050\n$ year_1              <dbl> 2008.029\n$ year_2              <dbl> 2008\n```\n:::\n:::\n\n\nThe mean and median are computed in the aforementioned example, but since more than one function is applied to the same variable, a numerical suffix is added based on the order in which our functions were defined inside the list, making mean 1 and median 2. This can be confusing and lead to errors later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        mean = ~mean(.,na.rm = TRUE),\n        median = ~median(.,na.rm = TRUE)\n      )\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ bill_length_mm_mean      <dbl> 43.92193\n$ bill_length_mm_median    <dbl> 44.45\n$ bill_depth_mm_mean       <dbl> 17.15117\n$ bill_depth_mm_median     <dbl> 17.3\n$ flipper_length_mm_mean   <dbl> 200.9152\n$ flipper_length_mm_median <dbl> 197\n$ body_mass_g_mean         <dbl> 4201.754\n$ body_mass_g_median       <dbl> 4050\n$ year_mean                <dbl> 2008.029\n$ year_median              <dbl> 2008\n```\n:::\n:::\n\n\nSince we defined the names of the functions in the example above and added them automatically as suffixes, it is now clearer what we are doing.\n\n## .names\n\nThe argument `.names` determines the name of resultant the variables after the functions are applied, so it allows us to change the names of the variables, this argument is:\n\n-   Optional\n\n-   The default is `NULL`\n\n-   Accepts as input:\n\n    -   A string, where we can use `{.col}` and `{.fn}` as variables to receive the respective names of the columns and/or functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  summarise(\n    across(\n      .cols = where(is.numeric),\n      .fns = list(\n        mean = ~mean(.,na.rm = TRUE),\n        median = ~median(.,na.rm = TRUE)\n      ),\n      .names = \"{.fn}----{.col}\"\n    )\n  ) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 10\n$ `mean----bill_length_mm`      <dbl> 43.92193\n$ `median----bill_length_mm`    <dbl> 44.45\n$ `mean----bill_depth_mm`       <dbl> 17.15117\n$ `median----bill_depth_mm`     <dbl> 17.3\n$ `mean----flipper_length_mm`   <dbl> 200.9152\n$ `median----flipper_length_mm` <dbl> 197\n$ `mean----body_mass_g`         <dbl> 4201.754\n$ `median----body_mass_g`       <dbl> 4050\n$ `mean----year`                <dbl> 2008.029\n$ `median----year`              <dbl> 2008\n```\n:::\n:::\n\n\nIn the example above we change the variables names so they start with the function applied followed by 4 hyphens and then the original columns names.\n\n# c_across\n\nThe function `c_across` is a cousin of `across` , let´s construct another data.frame to showcase it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nxpenguins <-\n  penguins %>% \n  group_by(species) %>% \n  summarise(\n    heaviest = max(body_mass_g,na.rm = TRUE),\n    lightest = min(body_mass_g,na.rm = TRUE)\n    ) %>%\n  pivot_longer(cols = -species) %>% \n  pivot_wider(names_from = species,values_from = value)\n\nxpenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 4\n  name     Adelie Chinstrap Gentoo\n  <chr>     <int>     <int>  <int>\n1 heaviest   4775      4800   6300\n2 lightest   2850      2700   3950\n```\n:::\n:::\n\n\nIn the preceding example, we create a data.frame in wide format, with a column for each species and two rows representing the heaviest and lightest penguins of each. Assume our goal is to calculate the total weight of the heaviest and lightest penguins, which entails adding the weights of the three species in a fourth column called `total weight`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins %>% \n  mutate(total_weight = Adelie + Chinstrap + Gentoo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 5\n  name     Adelie Chinstrap Gentoo total_weight\n  <chr>     <int>     <int>  <int>        <int>\n1 heaviest   4775      4800   6300        15875\n2 lightest   2850      2700   3950         9500\n```\n:::\n:::\n\n\nWe can use a simple solution of manually entering each variable name and adding each other, which works but is not ideal, especially when we have many columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins %>% \n  rowwise() %>% \n  mutate(total_weight = sum(c_across(-name)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 5\n# Rowwise: \n  name     Adelie Chinstrap Gentoo total_weight\n  <chr>     <int>     <int>  <int>        <int>\n1 heaviest   4775      4800   6300        15875\n2 lightest   2850      2700   3950         9500\n```\n:::\n:::\n\n\nAn alternative is to apply `c_across`, first it works together with the verb `rowwise` that make the commands below it to operate by row, not column.\n\nNot only that, but `c_across` differs from `across` in that it has only a `.cols` argument, so it must be placed within a function, which provides an advantage over the first approach in that we can now use the functions arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpenguins_na <- xpenguins\nxpenguins_na[1,3] <- NA\n  \nxpenguins_na %>% \n  rowwise() %>% \n  mutate(\n    total_weight_plus = Adelie + Chinstrap + Gentoo,\n    total_weight_cacross = sum(c_across(-name),na.rm = TRUE)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 6\n# Rowwise: \n  name     Adelie Chinstrap Gentoo total_weight_plus total_weight_cacross\n  <chr>     <int>     <int>  <int>             <int>                <int>\n1 heaviest   4775        NA   6300                NA                11075\n2 lightest   2850      2700   3950              9500                19000\n```\n:::\n:::\n\n\nFinally, above we show what would happen if we had an `NA` in the data. Most functions in R by default give `NA` as results if a `NA` is present in the data, so we can benefit from the use of the function `sum`, since it has an argument to ignore them (`na.rm = TRUE`).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}